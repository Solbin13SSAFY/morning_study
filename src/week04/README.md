# 4th_week morning study

## 02/11 Tue & 02/11 Thu 진행


**공통**

- 백준 31575 도시와 비트코인  https://www.acmicpc.net/problem/31575

- 백준 24444 알고리즘 수업 - 너비 우선 탐색1  https://www.acmicpc.net/problem/24444

- 백준 25418 정수 a를 k로 만들기  https://www.acmicpc.net/problem/25418

- 백준 2468 안전 영역 https://www.acmicpc.net/problem/2468


**IM 검정 대비 선택**

- 백준 27961 고양이는 많을수록 좋다 https://www.acmicpc.net/problem/27961

- 백준 14659 한조서열 https://www.acmicpc.net/problem/14659

- 백준 1026 보물  https://www.acmicpc.net/problem/1026

- 백준 13305 주유소 https://www.acmicpc.net/problem/13305

- 백준 30892 상어키우기 https://www.acmicpc.net/problem/30892

- 백준 12933 오리 https://www.acmicpc.net/problem/12933


---

### 보고서

**화요일**

1. 백준 31575 도시와 비트코인
  - 출발점과 도착점이 고정된 상황에서 목적지에 도달가능 여부를 확인하는 문제
  - DFS, BFS모두 사용할 수 있는 문제였음. 너비, 깊이 우선 탐색의 특징을 잘 이해하고 있어야 필요할 때
    잘 골라 쓸 수 있음
  - 0, 1로 정보가 제시될 때 boolean으로 받아 false, true로 조금 더 직관적으로 풀 수 있다.
 
2. 백준 24444 알고리즘 수업 - 너비 우선 탐색1
  - 그래프를 구현할 때 ArrayList<ArrayList<T>>의 형태로 사용하는 경우 선언 이후 노드의 수만큼 반복문을 돌려 new ArrayList<ArrayList<T>>를 추가해서 혼동을 방지할 수 있다.
  - 크기가 정해져 있는 경우 2차원 행렬을 이용할 수도 있었다.

3. 기타 문제 풀이방법 시 알아두면 좋은 내용!
  - BFS관련 문제를 풀 때 시간, 거리등을 우선으로 정렬해야 하는 경우가있을 때 PriorityQueue사용을 고려해 볼 수 있음
  - 클래스를 새롭게 정의하여 사용할 경우 Comparable을 구현하거나 익명클래스로 Comparator를 구현, compare를 재정의해서 사용한다.
  - 정렬 기준이 여러개일 때도 조건을 수정하여 원하는대로 정렬할 수 있으니 꼭 알아두도록 하자.
  - 개리멘더링 문제에서 그래프 탐색 경우의 수를 bit를 이용해서 계산해볼 수 있을 것 같다는 생각도 나왔으니 추후 관련 문제를 풀 때 참고하자.

🆕 11일 목요일 스터디
  - 2월 18일에 IM검정 시험을 대비하기 위해 새로운 문제 목록을 뽑아 가능한 만큼 풀어보고 만나는 것으로 결정

---

**목요일**

1. 백준 25418 정수 a를 k로 만들기
  - BFS를 사용하여 연산 단계를 진행해 나가면서 목표값을 찾을 수 있는 최소 연산횟수를 구하는 문제
  - 만든적 있는 수를 표시하기 위해 boolean[]을 사용하거나 Set을 이용할 수 있었음.(사실 Set이 아닌 다른 Collection이어도 될지도..)

2. 백준 2468 안전 영역
  - 주어진 땅의 높이 정보에서 비가 무작위로 왔을 때 만들어 지는 안전 영역의 갯수가 가장 많은 때의 영역의 수를 구하는 문제
  - 땅 높이의 범위 만큼 비가 온 경우를 모두 계산 할 수 있었고 안전 영역의 수가 바뀔 수 있는 경우를 구하기 위해 Set에 높이 정보를 담아 최대, 최소범위를 넘어가는 값을 추가한 조건들에 대해서 검사할 수 있었다.

IM 대비 문제 중 크게 어렵지 않았던 문제는 넘어가고 알아두면 좋을 내용이 있었던 문제에 대해서 정리

1. 백준 27961 고양이는 많을수록 좋다
  - 목표값이 2의 배수의 범위 중 어디에 속해있는지 찾으면 풀 수 있는 문제
  - 추후 이진탐색과 같이 이진수를 다루어야 하는 문제를 풀기 전 알아 두면 좋을 것이다!
    - Long.numberOfTrailingZeros(Long.highestOneBit(n-1))+2 -> 이진수의 가장 높은 비트 뒤쪽에 있는 0의 갯수를 카운트
    - (long)(Math.log(n-1)/Math.log(2))+2 -> 밑이 2인 log 이용
    - 보다 자세한 내용은 https://github.com/Solbin13SSAFY/morning_study/blob/main/src/week04/solbin/thu_boj_27961_%EA%B3%A0%EC%96%91%EC%9D%B4%EB%8A%94%EB%A7%8E%EC%9D%84%EC%88%98%EB%A1%9D%EC%A2%8B%EB%8B%A4.java를 참고하자!

2. 백준 30892 상어키우기
  - 상어가 제한된 수 만큼 물고기를 먹어 몸집을 키울 수 있는 최대값을 구하는 문제
  - 시간관리를 위해 탐색의 범위를 최소화해야하는 문제 -> 이전에 탐색했던 정보를 어떻게 관리할지 생각이 필요했음
  - PriorityQueue<Integer>로 물고기 값을 담게 되면 크기정보를 기준으로 자동으로 오름차순 된다.
  - 꺼낸 물고기 값을 정렬된 상태를 유지하기 위해 꺼낸 뒤 stack에 담고 먹을 수 없는 물고기가 나오는 경우 stack 젤 위에 있는 물고기를 먹어 먹을 수 있는 물고기 중 가장 큰 것을 먹는 것을 보장할 수 있었다.
